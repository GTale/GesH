/**
 * 判断元素是否可见
 * 检查元素自身的可见性，不检查父元素
 */
function isElementVisible(element) {
  if (!element || element.nodeType !== 1) return false;
  
  const style = window.getComputedStyle(element);
  return style.display !== 'none' && 
         style.visibility !== 'hidden' && 
         style.opacity !== '0';
}

/**
 * 检查元素是否应该被排除（隐藏的元素）
 */
function shouldExcludeElement(element) {
  if (!element || element.nodeType !== 1) return true;
  
  // 排除特定标签
  const excludeTags = ['SCRIPT', 'STYLE', 'NOSCRIPT', 'LINK', 'META', 'BR', 'HR'];
  if (excludeTags.includes(element.tagName)) return true;
  
  // 检查可见性
  const style = window.getComputedStyle(element);
  return style.display === 'none' || 
         style.visibility === 'hidden' || 
         style.opacity === '0';
}

/**
 * 获取元素的直接文本内容（不包括子元素文本）
 */
function getDirectText(element) {
  let text = '';
  
  // 遍历所有子节点
  for (const node of element.childNodes) {
    if (node.nodeType === 3) { // 文本节点
      const trimmed = node.textContent.trim();
      if (trimmed) {
        text += (text ? ' ' : '') + trimmed;
      }
    }
  }
  
  return text || '*'; // 如果没有文本，返回 '*'
}

/**
 * 深度遍历DOM，生成目录结构
 * 返回格式: [{text: string, children: array, element: HTMLElement, depth: number}]
 */
function traverseDOM(root, depth = 0) {
  const result = [];
  
  if (shouldExcludeElement(root)) {
    return result;
  }
  
  // 获取当前节点的直接文本
  const nodeText = getDirectText(root);
  
  // 获取所有可见的子元素
  const childElements = [];
  for (let i = 0; i < root.children.length; i++) {
    const child = root.children[i];
    childElements.push(...traverseDOM(child, depth + 1));
  }
  
  // 构建当前节点
  const currentNode = {
    text: nodeText,
    children: childElements,
    element: root,
    depth: depth,
    isLeaf: childElements.length === 0
  };
  
  result.push(currentNode);
  return result;
}

/**
 * 压缩空节点 - 删除*节点，提升其子节点
 */
function compressEmptyNodes(nodes) {
  const result = [];
  
  for (const node of nodes) {
    // 如果是空节点（*），且不是叶子节点
    if (node.text === '*' && node.children.length > 0) {
      // 将子节点提升到当前层级（保持深度不变，但移除父节点）
      const compressedChildren = compressEmptyNodes(node.children);
      
      // 将压缩后的子节点直接添加到结果中
      for (const child of compressedChildren) {
        result.push(child);
      }
    } else {
      // 保持节点，但递归压缩其子节点
      const newNode = {
        ...node,
        children: compressEmptyNodes(node.children)
      };
      result.push(newNode);
    }
  }
  
  return result;
}

/**
 * 判断节点是否为叶子节点（在压缩后）
 */
function isLeafNode(node) {
  return node.children.length === 0;
}

/**
 * 生成最终的目录字符串
 */
function generateDirectoryLines(nodes, depth = 0, parentIsEmpty = false) {
  const lines = [];
  const indent = '  '.repeat(depth);
  
  // 如果父节点是空的，我们当前处理的节点已经是提升后的
  // 这种情况下，我们不需要将兄弟节点连接
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    const nextNode = nodes[i + 1];
    
    if (isLeafNode(node)) {
      // 叶子节点，直接输出
      lines.push(`${indent}${node.text}`);
    } else {
      // 非叶子节点
      // 检查所有直接子节点是否都是叶子节点
      const allChildrenAreLeaves = node.children.every(child => isLeafNode(child));
      
      if (allChildrenAreLeaves) {
        // 所有子节点都是叶子节点，用-连接它们
        const childTexts = node.children.map(child => child.text);
        const combinedText = childTexts.join('-');
        lines.push(`${indent}${node.text}`);
        lines.push(`${indent}  ${combinedText}`);
      } else {
        // 有嵌套的子节点，递归处理
        lines.push(`${indent}${node.text}`);
        lines.push(...generateDirectoryLines(node.children, depth + 1));
      }
    }
  }
  
  return lines;
}

/**
 * 生成并打印目录结构
 */
function printDOMDirectory() {
  console.log('DOM目录结构:');
  console.log('============');
  
  try {
    // 从body开始遍历，或者你可以指定其他根节点
    const rootElement = document.body;
    
    // 第一步：遍历DOM树
    const domTree = traverseDOM(rootElement);
    
    // 第二步：压缩空节点（删除*节点）
    const compressedTree = compressEmptyNodes(domTree);
    
    // 第三步：生成目录行
    const directoryLines = generateDirectoryLines(compressedTree);
    
    // 第四步：打印
    directoryLines.forEach(line => console.log(line));
    
    console.log('============');
    console.log('目录生成完成');
  } catch (error) {
    console.error('生成目录时出错:', error);
  }
}

// 辅助函数：可视化DOM结构（调试用）
function visualizeDOMTree(nodes, depth = 0) {
  const indent = '  '.repeat(depth);
  for (const node of nodes) {
    console.log(`${indent}${node.text} (depth: ${node.depth}, children: ${node.children.length})`);
    visualizeDOMTree(node.children, depth + 1);
  }
}

// 页面加载完成后自动生成目录
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', printDOMDirectory);
} else {
  printDOMDirectory();
}