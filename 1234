/**
 * 判断元素是否可见
 * 检查元素自身的可见性，不检查父元素
 */
function isElementVisible(element) {
  if (!element || element.nodeType !== 1) return false;
  
  const style = window.getComputedStyle(element);
  return style.display !== 'none' && 
         style.visibility !== 'hidden' && 
         style.opacity !== '0';
}

/**
 * 检查元素是否应该被排除（隐藏的元素）
 */
function shouldExcludeElement(element) {
  if (!element || element.nodeType !== 1) return true;
  
  // 排除特定标签
  const excludeTags = ['SCRIPT', 'STYLE', 'NOSCRIPT', 'LINK', 'META', 'BR', 'HR'];
  if (excludeTags.includes(element.tagName)) return true;
  
  // 检查可见性
  const style = window.getComputedStyle(element);
  return style.display === 'none' || 
         style.visibility === 'hidden' || 
         style.opacity === '0';
}

/**
 * 获取元素的直接文本内容（不包括子元素文本）
 */
function getDirectText(element) {
  let text = '';
  
  // 遍历所有子节点
  for (const node of element.childNodes) {
    if (node.nodeType === 3) { // 文本节点
      const trimmed = node.textContent.trim();
      if (trimmed) {
        text += (text ? ' ' : '') + trimmed;
      }
    }
  }
  
  return text || '*'; // 如果没有文本，返回 '*'
}

/**
 * 深度遍历DOM，生成树形结构
 */
function buildDOMTree(root, depth = 0) {
  if (shouldExcludeElement(root)) {
    return null;
  }
  
  // 处理当前节点
  const node = {
    text: getDirectText(root),
    children: [],
    depth: depth,
    element: root.tagName,
    isLeaf: false
  };
  
  // 处理子节点
  for (let i = 0; i < root.children.length; i++) {
    const child = root.children[i];
    const childNode = buildDOMTree(child, depth + 1);
    if (childNode) {
      node.children.push(childNode);
    }
  }
  
  // 标记是否为叶子节点
  node.isLeaf = node.children.length === 0;
  
  return node;
}

/**
 * 压缩树 - 删除空的中间节点（*），提升其子节点
 * @returns 处理后的节点或节点数组
 */
function compressTree(node) {
  if (!node) return null;
  
  // 先递归压缩子节点
  const compressedChildren = [];
  for (const child of node.children) {
    const compressedChild = compressTree(child);
    if (compressedChild) {
      // 如果压缩后返回的是数组，展开
      if (Array.isArray(compressedChild)) {
        compressedChildren.push(...compressedChild);
      } else {
        compressedChildren.push(compressedChild);
      }
    }
  }
  
  // 如果当前节点是空节点（*），且不是叶子节点
  if (node.text === '*' && compressedChildren.length > 0) {
    // 返回压缩后的子节点数组（不包含当前节点）
    return compressedChildren;
  }
  
  // 否则，保持节点结构，但更新子节点
  return {
    text: node.text,
    children: compressedChildren,
    depth: node.depth,
    element: node.element,
    isLeaf: compressedChildren.length === 0
  };
}

/**
 * 处理叶子节点的兄弟节点连接
 * 如果所有兄弟节点都是叶子节点，将它们连接起来
 */
function processLeafConnections(nodes, isFromCompression = false) {
  if (!nodes || nodes.length === 0) return nodes;
  
  const result = [];
  
  // 递归处理子节点
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    
    if (node.children && node.children.length > 0) {
      // 递归处理子节点
      node.children = processLeafConnections(node.children, isFromCompression || node.isCompressed);
    }
    
    result.push(node);
  }
  
  // 如果是压缩层级，不进行连接
  if (isFromCompression) {
    return result;
  }
  
  // 检查当前层级是否都是叶子节点
  const allLeaves = result.every(node => node.isLeaf);
  
  if (allLeaves && result.length > 1) {
    // 将所有叶子节点的文本用-连接
    const leafTexts = result.map(node => node.text).filter(text => text !== '*');
    
    if (leafTexts.length > 0) {
      // 只保留第一个节点，将其他节点的文本合并到第一个节点
      const firstNode = result[0];
      firstNode.text = leafTexts.join('-');
      firstNode.isConnectedLeaf = true;
      firstNode.originalChildren = result.slice(1).map(n => n.text);
      
      // 只返回第一个节点
      return [firstNode];
    }
  }
  
  return result;
}

/**
 * 处理压缩后的树，标记压缩节点
 */
function processCompressedTree(nodes) {
  if (!nodes || nodes.length === 0) return nodes;
  
  const result = [];
  
  for (const node of nodes) {
    // 标记节点是否来自压缩
    const processedNode = {
      ...node,
      isCompressed: node.text === '*' || node.isCompressed || false
    };
    
    // 递归处理子节点
    if (node.children && node.children.length > 0) {
      processedNode.children = processCompressedTree(node.children);
    }
    
    result.push(processedNode);
  }
  
  return result;
}

/**
 * 生成DOM目录的JSON对象
 */
function generateDOMDirectoryJSON(rootElement = document.body) {
  try {
    // 第一步：构建DOM树
    const domTree = buildDOMTree(rootElement);
    
    // 第二步：压缩树（删除空节点）
    const compressedResult = compressTree(domTree);
    
    // 处理压缩结果：确保是数组格式
    let compressedTree;
    if (Array.isArray(compressedResult)) {
      compressedTree = compressedResult;
    } else if (compressedResult) {
      compressedTree = [compressedResult];
    } else {
      compressedTree = [];
    }
    
    // 第三步：标记压缩节点
    const processedTree = processCompressedTree(compressedTree);
    
    // 第四步：处理叶子节点连接
    const finalTree = processLeafConnections(processedTree);
    
    // 返回JSON对象
    return {
      metadata: {
        generatedAt: new Date().toISOString(),
        rootElement: rootElement.tagName,
        totalNodes: countNodes(finalTree)
      },
      directory: finalTree
    };
  } catch (error) {
    console.error('生成DOM目录JSON时出错:', error);
    return {
      error: error.message,
      directory: []
    };
  }
}

/**
 * 计算节点数量
 */
function countNodes(nodes) {
  if (!nodes || nodes.length === 0) return 0;
  
  let count = 0;
  for (const node of nodes) {
    count++; // 当前节点
    if (node.children && node.children.length > 0) {
      count += countNodes(node.children);
    }
  }
  
  return count;
}

/**
 * 打印DOM目录的JSON对象
 */
function printDOMDirectoryJSON(rootSelector = 'body') {
  console.log('DOM目录结构(JSON格式):');
  console.log('=====================');
  
  const rootElement = document.querySelector(rootSelector);
  if (!rootElement) {
    console.error(`找不到元素: ${rootSelector}`);
    return;
  }
  
  const directoryJSON = generateDOMDirectoryJSON(rootElement);
  
  // 格式化的JSON输出
  console.log(JSON.stringify(directoryJSON, null, 2));
  
  console.log('=====================');
  console.log('目录生成完成');
  
  return directoryJSON;
}

/**
 * 生成HTML示例并测试
 */
function createExampleHTML() {
  const exampleHTML = `
<!DOCTYPE html>
<html>
<head>
  <title>DOM目录示例</title>
</head>
<body>
  <div id="container">
    <header>
      <h1>页面标题</h1>
      <nav style="display:none">
        <ul>
          <li>隐藏的链接1</li>
          <li>隐藏的链接2</li>
        </ul>
      </nav>
    </header>
    <main>
      <section>
        <h2>第一部分</h2>
        <p>这是第一段文字。</p>
        <p>这是第二段文字。</p>
      </section>
      <section>
        <h2>第二部分</h2>
        <div class="content">
          <span>内容项1</span>
          <span>内容项2</span>
          <span>内容项3</span>
        </div>
        <div class="nested">
          <div>*
            <a href="#">嵌套链接1</a>
            <a href="#">嵌套链接2</a>
          </div>
        </div>
      </section>
    </main>
    <footer>
      <p>页脚文本</p>
    </footer>
  </div>
</body>
</html>
  `;
  
  console.log('示例HTML结构:');
  console.log(exampleHTML);
}

// 页面加载完成后自动生成目录
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    printDOMDirectoryJSON('body');
  });
} else {
  printDOMDirectoryJSON('body');
}

// 导出函数以便在其他地方使用
window.DOMDirectory = {
  generateJSON: generateDOMDirectoryJSON,
  printJSON: printDOMDirectoryJSON,
  createExample: createExampleHTML
};