function domToTree(root = document.body) {
  // 递归遍历DOM节点
  function traverse(node) {
    // 跳过不可见的节点
    if (node.nodeType === Node.ELEMENT_NODE) {
      const style = window.getComputedStyle(node);
      if (style.display === 'none' || 
          style.visibility === 'hidden' ||
          style.opacity === '0' ||
          node.hidden) {
        return null;
      }
      
      // 过滤不需要的标签
      const skipTags = ['SCRIPT', 'STYLE', 'LINK', 'META', 'NOSCRIPT'];
      if (skipTags.includes(node.tagName)) {
        return null;
      }
    }
    
    // 如果是文本节点
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent.trim();
      return text ? { type: 'text', content: text } : null;
    }
    
    // 如果是元素节点
    if (node.nodeType === Node.ELEMENT_NODE) {
      // 创建当前节点对象
      const treeNode = {
        type: 'element',
        tag: node.tagName.toLowerCase(),
        children: [],
        attributes: Array.from(node.attributes).map(attr => ({
          name: attr.name,
          value: attr.value
        }))
      };
      
      // 如果有ID或类名，添加到节点中
      if (node.id) treeNode.id = node.id;
      if (node.className) treeNode.className = node.className;
      
      // 遍历子节点
      const childNodes = Array.from(node.childNodes);
      for (const child of childNodes) {
        const childTree = traverse(child);
        if (childTree) {
          treeNode.children.push(childTree);
        }
      }
      
      // 如果元素本身有文本内容（如input的value）
      if (node.value && typeof node.value === 'string') {
        treeNode.value = node.value.trim();
      }
      
      // 如果有alt属性（图片等）
      if (node.alt) {
        treeNode.alt = node.alt;
      }
      
      // 如果元素没有子节点但有文本内容，添加文本节点
      if (treeNode.children.length === 0) {
        const text = node.textContent.trim();
        if (text) {
          treeNode.children.push({
            type: 'text',
            content: text
          });
        } else {
          // 如果是自闭合标签或空元素，检查是否需要保留
          const voidTags = ['img', 'br', 'hr', 'input', 'meta', 'link'];
          if (!voidTags.includes(treeNode.tag)) {
            // 如果没有内容，返回null（可选：可以返回空节点）
            return null;
          }
        }
      }
      
      return treeNode;
    }
    
    return null;
  }
  
  return traverse(root);
}

// 更简洁的版本 - 只提取文本结构
function domToTextTree(root = document.body) {
  function traverse(node) {
    // 跳过隐藏元素
    if (node.nodeType === Node.ELEMENT_NODE) {
      const style = window.getComputedStyle(node);
      if (style.display === 'none' || style.visibility === 'hidden') {
        return null;
      }
      
      if (['SCRIPT', 'STYLE'].includes(node.tagName)) {
        return null;
      }
    }
    
    // 文本节点
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent.trim();
      return text ? { text } : null;
    }
    
    // 元素节点
    if (node.nodeType === Node.ELEMENT_NODE) {
      const nodeData = {
        tag: node.tagName.toLowerCase(),
        children: []
      };
      
      // 遍历子节点
      for (const child of node.childNodes) {
        const childResult = traverse(child);
        if (childResult) {
          nodeData.children.push(childResult);
        }
      }
      
      // 合并连续的文本节点
      if (nodeData.children.length > 0) {
        const mergedChildren = [];
        let currentText = '';
        
        for (const child of nodeData.children) {
          if (child.text) {
            currentText += (currentText ? ' ' : '') + child.text;
          } else {
            if (currentText) {
              mergedChildren.push({ text: currentText });
              currentText = '';
            }
            mergedChildren.push(child);
          }
        }
        
        if (currentText) {
          mergedChildren.push({ text: currentText });
        }
        
        nodeData.children = mergedChildren;
      }
      
      // 如果只有一个文本子节点，可以直接提取文本
      if (nodeData.children.length === 1 && nodeData.children[0].text) {
        return { 
          tag: nodeData.tag,
          text: nodeData.children[0].text 
        };
      }
      
      // 如果没有子节点但有文本内容
      if (nodeData.children.length === 0) {
        const text = node.textContent.trim();
        if (text) {
          return { tag: nodeData.tag, text };
        }
        return null;
      }
      
      return nodeData;
    }
    
    return null;
  }
  
  return traverse(root);
}

// 使用示例
const tree = domToTree(document.body);
console.log(tree);

// 可视化显示树结构
function printTree(node, indent = 0) {
  const spaces = ' '.repeat(indent * 2);
  
  if (node.type === 'text') {
    console.log(spaces + `"${node.content}"`);
  } else if (node.type === 'element') {
    console.log(spaces + `<${node.tag}>`);
    node.children.forEach(child => printTree(child, indent + 1));
  }
}

// 获取页面所有文本内容（扁平化）
function getAllTextFromTree(tree) {
  const texts = [];
  
  function collectText(node) {
    if (node.type === 'text') {
      texts.push(node.content);
    } else if (node.children) {
      node.children.forEach(collectText);
    }
  }
  
  collectText(tree);
  return texts;
}

// 优化版：使用迭代而非递归（避免栈溢出）
function domToTreeIterative(root = document.body) {
  const stack = [{ node: root, parent: null }];
  const treeRoot = { type: 'root', children: [] };
  const nodeMap = new Map();
  
  nodeMap.set(root, treeRoot);
  
  while (stack.length > 0) {
    const { node, parent } = stack.pop();
    const treeNode = nodeMap.get(node);
    
    // 处理当前节点
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent.trim();
      if (text && parent) {
        const textNode = { type: 'text', content: text };
        nodeMap.get(parent).children.push(textNode);
      }
    } 
    else if (node.nodeType === Node.ELEMENT_NODE) {
      const style = window.getComputedStyle(node);
      if (style.display === 'none' || style.visibility === 'hidden') {
        continue;
      }
      
      if (['SCRIPT', 'STYLE'].includes(node.tagName)) {
        continue;
      }
      
      const elementNode = {
        type: 'element',
        tag: node.tagName.toLowerCase(),
        children: []
      };
      
      if (node.id) elementNode.id = node.id;
      
      // 连接到父节点
      if (parent) {
        nodeMap.get(parent).children.push(elementNode);
      }
      
      // 将子节点逆序压入栈中（保证处理顺序）
      const children = Array.from(node.childNodes).reverse();
      for (const child of children) {
        stack.push({ node: child, parent: node });
        nodeMap.set(child, elementNode);
      }
    }
  }
  
  return treeRoot;
}