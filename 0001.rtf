' VBA 模块代码
Option Explicit

' API 声明
#If VBA7 Then
    Private Declare PtrSafe Function CreateMutex Lib "kernel32" Alias "CreateMutexA" (ByVal lpMutexAttributes As Long, ByVal bInitialOwner As Long, ByVal lpName As String) As LongPtr
    Private Declare PtrSafe Function ReleaseMutex Lib "kernel32" (ByVal hMutex As LongPtr) As Long
    Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
    Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal dwMilliseconds As Long) As Long
    Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
    Private Declare Function CreateMutex Lib "kernel32" Alias "CreateMutexA" (ByVal lpMutexAttributes As Long, ByVal bInitialOwner As Long, ByVal lpName As String) As Long
    Private Declare Function ReleaseMutex Lib "kernel32" (ByVal hMutex As Long) As Long
    Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
    Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
    Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

' 常量定义
Const INFINITE As Long = &HFFFF
Const WAIT_OBJECT_0 As Long = 0
Const WAIT_TIMEOUT As Long = &H102
Const TEMP_FOLDER As String = "C:\Temp\PComm\"
Const MUTEX_NAME As String = "Global\PCommVBSMutex"
Const POLL_INTERVAL As Long = 10  ' 10ms 轮询间隔
Const MAX_WAIT_MS As Long = 10000 ' 10秒超时
Const FILE_LOCK_TIMEOUT As Long = 5000 ' 5秒文件锁超时

' 初始化函数
Sub InitializePComm()
    ' 确保临时目录存在
    If Dir(TEMP_FOLDER, vbDirectory) = "" Then MkDir TEMP_FOLDER
End Sub

' 启动监听服务
Sub StartListener()
    On Error Resume Next
    ' 确保VBS脚本存在
    Dim vbsPath As String
    vbsPath = ThisWorkbook.Path & "\PCommListener.vbs"
    If Dir(vbsPath) = "" Then
        MsgBox "VBS监听脚本不存在: " & vbsPath, vbCritical
        Exit Sub
    End If
    
    ' 启动VBS监听服务
    Dim wsh As Object
    Set wsh = CreateObject("WScript.Shell")
    wsh.Run "wscript """ & vbsPath & """", 0, False
    Set wsh = Nothing
    
    ' 等待服务初始化
    Sleep 500
End Sub

' 获取文件锁
Function AcquireFileLock(lockFilePath As String, Optional timeoutMs As Long = FILE_LOCK_TIMEOUT) As Boolean
    Dim startTime As Double
    startTime = Timer * 1000 ' 转换为毫秒
    
    ' 尝试获取文件锁
    Do While True
        On Error Resume Next
        ' 尝试创建锁文件 - 如果成功则表示获取锁
        Open lockFilePath For Output As #1
        If Err.Number = 0 Then
            Print #1, "Locked by VBA at " & Now
            Close #1
            AcquireFileLock = True
            Exit Function
        End If
        
        ' 检查超时
        If (Timer * 1000 - startTime) > timeoutMs Then
            Exit Function
        End If
        
        ' 短时间等待后重试
        Sleep 50
        DoEvents
    Loop
End Function

' 释放文件锁
Sub ReleaseFileLock(lockFilePath As String)
    On Error Resume Next
    If Dir(lockFilePath) <> "" Then
        Kill lockFilePath
    End If
End Sub

' 发送命令核心函数 (使用文件锁)
Function SendCommand(cmdType As String, Optional cmdValue As String = "") As String
    Dim commandFile As String, resultFile As String, lockFile As String
    commandFile = TEMP_FOLDER & "PCommCmd.dat"
    resultFile = TEMP_FOLDER & "PCommRes.dat"
    lockFile = TEMP_FOLDER & "PCommLock.lck"
    
    ' 获取文件锁
    If Not AcquireFileLock(lockFile) Then
        SendCommand = "ERROR=获取文件锁超时"
        Exit Function
    End If
    
    On Error GoTo Cleanup
    
    ' 删除旧结果文件
    If Dir(resultFile) <> "" Then Kill resultFile
    
    ' 追加命令到文件
    AppendToCommandFile commandFile, cmdType, cmdValue
    
    ' 等待响应
    Dim response As String, elapsed As Double, found As Boolean
    Dim startTime As Double
    startTime = Timer * 1000
    found = False
    
    Do
        If Dir(resultFile) <> "" Then
            response = ReadBinaryFile(resultFile)
            If InStr(1, response, cmdType & "=", vbBinaryCompare) > 0 Then
                SendCommand = ExtractResult(response, cmdType)
                found = True
                Exit Do
            End If
        End If
        
        ' 检查超时
        elapsed = Timer * 1000 - startTime
        If elapsed > MAX_WAIT_MS Then
            SendCommand = "ERROR=等待响应超时 (" & Format(elapsed, "0") & "ms)"
            Exit Do
        End If
        
        ' 短间隔等待
        Sleep POLL_INTERVAL
        DoEvents
    Loop
    
Cleanup:
    ' 释放文件锁
    ReleaseFileLock lockFile
End Function

' 追加命令到文件 (原子操作)
Private Sub AppendToCommandFile(filePath As String, cmdType As String, cmdValue As String)
    Dim fileNum As Integer
    fileNum = FreeFile
    
    ' 打开文件追加写入
    Open filePath For Append As #fileNum
    Print #fileNum, cmdType & "=" & cmdValue & "|";
    Close #fileNum
End Sub

' 读取二进制文件
Private Function ReadBinaryFile(filePath As String) As String
    If Dir(filePath) = "" Then Exit Function
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    Open filePath For Binary Access Read As #fileNum
    ReadBinaryFile = Space(LOF(fileNum))
    Get #fileNum, , ReadBinaryFile
    Close #fileNum
End Function

' 从响应中提取结果
Private Function ExtractResult(fullResponse As String, cmdType As String) As String
    Dim startPos As Long
    startPos = InStr(1, fullResponse, cmdType & "=", vbBinaryCompare)
    If startPos = 0 Then
        ExtractResult = "ERROR=未找到响应类型"
        Exit Function
    End If
    
    Dim resultStart As Long
    resultStart = startPos + Len(cmdType) + 1
    
    ' 查找结果结束位置
    Dim endPos As Long
    endPos = InStr(resultStart, fullResponse, "|", vbBinaryCompare)
    If endPos = 0 Then endPos = Len(fullResponse) + 1
    
    ExtractResult = Mid(fullResponse, resultStart, endPos - resultStart)
End Function

' ==============================
' 封装的命令函数
' ==============================

Function ConnectSession(sessionName As String) As String
    ConnectSession = SendCommand("CONN", sessionName)
End Function

Function SendKeysToSession(keys As String) As String
    SendKeysToSession = SendCommand("KEYS", keys)
End Function

Function WaitForText(text As String) As String
    WaitForText = SendCommand("WAIT", text)
End Function

Function GetScreenText(row As Integer, col As Integer, length As Integer) As String
    GetScreenText = SendCommand("GET", row & "," & col & "," & length)
End Function

Function GetCursorPosition() As String
    GetCursorPosition = SendCommand("POS")
End Function

Function CaptureScreen() As String
    CaptureScreen = SendCommand("SCRN")
End Function

Function DisconnectSession() As String
    DisconnectSession = SendCommand("DISC")
End Function

Function StopListener() As String
    StopListener = SendCommand("STOP")
End Function

' ==============================
' 示例工作流程
' ==============================

Sub SampleWorkflow()
    InitializePComm
    StartListener
    
    ' 连接到主机会话
    Dim result As String
    result = ConnectSession("SESSION_A")
    If Left(result, 5) = "ERROR" Then
        MsgBox "连接失败: " & result, vbCritical
        Exit Sub
    End If
    
    ' 发送多个并行命令
    Dim responses(1 To 3) As String
    responses(1) = GetScreenText(5, 10, 20)
    responses(2) = GetScreenText(8, 15, 15)
    responses(3) = GetCursorPosition()
    
    ' 处理结果
    For i = 1 To 3
        Debug.Print "响应 " & i & ": " & responses(i)
    Next
    
    ' 断开连接
    result = DisconnectSession()
    
    ' 停止监听服务
    result = StopListener()
    
    MsgBox "工作流程完成!", vbInformation
End Sub








' File: PCommListener.vbs
Option Explicit

' 配置参数
Const POLL_INTERVAL = 50  ' 50ms轮询间隔
Const MAX_WAIT = 30000    ' 30秒超时
Const FILE_LOCK_TIMEOUT = 5000 ' 5秒文件锁超时

' 文件路径
Dim fso, tempFolder, commandFile, resultFile, lockFile
Set fso = CreateObject("Scripting.FileSystemObject")
tempFolder = "C:\Temp\PComm\"
commandFile = tempFolder & "PCommCmd.dat"
resultFile = tempFolder & "PCommRes.dat"
lockFile = tempFolder & "PCommLock.lck"

' 确保临时目录存在
If Not fso.FolderExists(tempFolder) Then
    fso.CreateFolder tempFolder
End If

' 创建初始文件
CreateEmptyFile commandFile
CreateEmptyFile resultFile

' 初始化PComm对象
Dim AutECLPS, AutECLSess, sessionConnected, currentSession
Set AutECLPS = CreateObject("PCOMM.autECLPS")
Set AutECLSess = CreateObject("PCOMM.autECLSession")
sessionConnected = False
currentSession = ""

' 主监听循环
Do While True
    ProcessCommands
    WScript.Sleep POLL_INTERVAL
Loop

' 获取文件锁 (VBS 版本)
Function AcquireFileLock()
    Dim startTime
    startTime = Timer * 1000 ' 转换为毫秒
    
    ' 尝试获取文件锁
    Do While True
        On Error Resume Next
        ' 尝试创建锁文件
        fso.CreateTextFile lockFile, True
        If Err.Number = 0 Then
            AcquireFileLock = True
            Exit Function
        End If
        
        ' 检查超时
        If (Timer * 1000 - startTime) > FILE_LOCK_TIMEOUT Then
            Exit Function
        End If
        
        ' 短时间等待后重试
        WScript.Sleep 50
    Loop
End Function

' 释放文件锁 (VBS 版本)
Sub ReleaseFileLock()
    On Error Resume Next
    If fso.FileExists(lockFile) Then
        fso.DeleteFile lockFile, True
    End If
End Sub

' 处理命令 (带文件锁保护)
Sub ProcessCommands()
    ' 检查文件锁
    If Not AcquireFileLock() Then Exit Sub
    
    On Error Resume Next
    
    Dim fileSize, commandData, commands
    fileSize = GetFileSize(commandFile)
    
    ' 如果有新指令
    If fileSize > 0 Then
        commandData = ReadBinaryFile(commandFile)
        commands = Split(commandData, "|")
        
        ' 处理每个命令
        Dim i, processedCount
        processedCount = 0
        
        For i = 0 To UBound(commands)
            If Trim(commands(i)) <> "" Then
                Dim parts, commandType, commandValue
                parts = Split(commands(i), "=", 2)
                commandType = parts(0)
                
                If UBound(parts) >= 1 Then 
                    commandValue = parts(1)
                Else
                    commandValue = ""
                End If
                
                ExecuteCommand commandType, commandValue
                processedCount = processedCount + 1
            End If
        Next
        
        ' 移除已处理命令
        If processedCount > 0 Then
            ' 只保留未处理命令
            Dim remainingCommands, newCommandData
            newCommandData = ""
            
            For i = processedCount To UBound(commands)
                If Trim(commands(i)) <> "" Then
                    newCommandData = newCommandData & commands(i) & "|"
                End If
            Next
            
            ' 更新命令文件
            WriteBinaryFile commandFile, newCommandData
        End If
    End If
    
    ' 释放文件锁
    ReleaseFileLock
End Sub

' ==============================
' PComm 操作函数 (保持不变)
' ==============================

Function ConnectSession(sessionName)
    ' ... 与之前相同 ...
End Function

Function SendKeys(keys)
    ' ... 与之前相同 ...
End Function

Function WaitForString(text)
    ' ... 与之前相同 ...
End Function

Function GetScreenText(row, col, length)
    ' ... 与之前相同 ...
End Function

Function GetCursorPosition()
    ' ... 与之前相同 ...
End Function

Function CaptureScreen()
    ' ... 与之前相同 ...
End Function

Function DisconnectSession()
    ' ... 与之前相同 ...
End Function

' ==============================
' 文件操作函数
' ==============================

Sub CreateEmptyFile(filePath)
    On Error Resume Next
    With fso.CreateTextFile(filePath, True)
        .Write ""
        .Close
    End With
End Sub

Function ReadBinaryFile(filePath)
    On Error Resume Next
    If Not fso.FileExists(filePath) Then Exit Function
    
    With fso.GetFile(filePath).OpenAsTextStream(1) ' 1 = ForReading
        ReadBinaryFile = .ReadAll
        .Close
    End With
End Function

Sub WriteBinaryFile(filePath, content)
    On Error Resume Next
    With fso.CreateTextFile(filePath, True)
        .Write content
        .Close
    End With
End Sub

Function GetFileSize(filePath)
    On Error Resume Next
    If fso.FileExists(filePath) Then
        GetFileSize = fso.GetFile(filePath).Size
    Else
        GetFileSize = 0
    End If
End Function
